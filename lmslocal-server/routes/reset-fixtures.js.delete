/*
DISABLED: Manual fixture management - now managed via backend fixture service (push-fixtures-to-competitions and push-results-to-competitions APIs)
This entire API has been disabled. To re-enable: uncomment this entire file and restore route registration in server.js

=========== ORIGINAL CODE BELOW (COMMENTED OUT) ===========
/*
=======================================================================================================================================
API Route: reset-fixtures
=======================================================================================================================================
Method: POST
Purpose: Resets all fixtures and picks for a round, allowing admin to start over with fixture creation. Only works for unlocked rounds with no processed results.
=======================================================================================================================================
Request Payload:
{
  "round_id": 5                                // integer, required - ID of the round to reset fixtures for
}

Success Response (ALWAYS HTTP 200):
{
  "return_code": "SUCCESS",
  "message": "Fixtures reset successfully",    // string, confirmation message
  "reset_summary": {
    "round_number": 3,                         // integer, round number that was reset
    "fixtures_removed": 8,                     // integer, number of fixtures deleted
    "picks_removed": 12,                       // integer, number of picks deleted
    "teams_restored": 15,                      // integer, number of team-user combinations restored to allowed_teams
    "players_affected": 12                     // integer, number of players who had picks removed
  }
}

Error Response (ALWAYS HTTP 200):
{
  "return_code": "ERROR_TYPE",
  "message": "Descriptive error message"       // string, user-friendly error description
}
=======================================================================================================================================
Return Codes:
"SUCCESS"
"VALIDATION_ERROR"
"UNAUTHORIZED"
"ROUND_NOT_FOUND"
"ACCESS_DENIED"
"ROUND_LOCKED"
"RESULTS_PROCESSED"
"NO_FIXTURES_TO_RESET"
"SERVER_ERROR"
=======================================================================================================================================
*/

const express = require('express');
const { query, transaction } = require('../database');
const { verifyToken } = require('../middleware/auth');
const { logApiCall } = require('../utils/apiLogger');
const router = express.Router();

router.post('/', verifyToken, async (req, res) => {
  logApiCall('reset-fixtures');
  
  try {
    // Extract request parameters and authenticated user ID
    const { round_id } = req.body;
    const authenticated_user_id = req.user.id;

    // === INPUT VALIDATION ===
    // Validate round_id is provided and is a valid integer
    if (!round_id || !Number.isInteger(round_id)) {
      return res.json({
        return_code: "VALIDATION_ERROR",
        message: "Round ID is required and must be a number"
      });
    }

    // === COMPREHENSIVE VALIDATION QUERY ===
    // Single query to validate round access, permissions, and gather reset data
    // This eliminates multiple queries and provides all needed validation in one call
    const validationResult = await query(`
      SELECT 
        -- === ROUND AND COMPETITION INFO ===
        r.id as round_id,                             -- Round identifier for validation
        r.competition_id,                             -- Competition ID for operations
        r.round_number,                               -- Round number for display and logging
        r.lock_time,                                  -- Round lock time for timing validation
        c.organiser_id,                               -- Competition organiser ID for authorization
        c.name as competition_name,                   -- Competition name for audit logging
        
        -- === AUTHORIZATION CHECK ===
        CASE WHEN c.organiser_id = $2 THEN true ELSE false END as is_admin,  -- User is competition organiser
        
        -- === TIMING VALIDATION ===
        CASE WHEN CURRENT_TIMESTAMP >= r.lock_time THEN true ELSE false END as is_round_locked,  -- Round is locked
        
        -- === FIXTURE AND PICK COUNTS (FOR RESET SUMMARY) ===
        COALESCE(fixture_stats.fixture_count, 0) as fixture_count,           -- Number of fixtures to be deleted
        COALESCE(pick_stats.pick_count, 0) as pick_count,                   -- Number of picks to be deleted
        COALESCE(pick_stats.affected_players, 0) as affected_players,        -- Number of players with picks
        
        -- === RESULTS PROCESSING CHECK ===
        COALESCE(processed_fixtures.processed_count, 0) as processed_count   -- Number of fixtures with results
        
      FROM round r
      INNER JOIN competition c ON r.competition_id = c.id
      
      -- === GET FIXTURE STATISTICS ===
      -- Count fixtures in this round for reset summary
      LEFT JOIN (
        SELECT 
          f.round_id,
          COUNT(*) as fixture_count
        FROM fixture f
        WHERE f.round_id = $1
        GROUP BY f.round_id
      ) fixture_stats ON r.id = fixture_stats.round_id
      
      -- === GET PICK STATISTICS ===
      -- Count picks and affected players for reset summary
      LEFT JOIN (
        SELECT 
          p.round_id,
          COUNT(*) as pick_count,
          COUNT(DISTINCT p.user_id) as affected_players
        FROM pick p
        WHERE p.round_id = $1
        GROUP BY p.round_id
      ) pick_stats ON r.id = pick_stats.round_id
      
      -- === CHECK FOR PROCESSED RESULTS ===
      -- Verify no fixtures have been processed (have results set)
      LEFT JOIN (
        SELECT 
          f.round_id,
          COUNT(*) as processed_count
        FROM fixture f
        WHERE f.round_id = $1 AND f.result IS NOT NULL
        GROUP BY f.round_id
      ) processed_fixtures ON r.id = processed_fixtures.round_id
      
      WHERE r.id = $1  -- Filter to requested round only
    `, [round_id, authenticated_user_id]);

    // === VALIDATION CHECKS ===
    // Check if round exists and validation data is available
    if (validationResult.rows.length === 0) {
      return res.json({
        return_code: "ROUND_NOT_FOUND",
        message: "Round not found"
      });
    }

    const validation = validationResult.rows[0];

    // Authorization: Only competition organiser can reset fixtures
    if (!validation.is_admin) {
      return res.json({
        return_code: "ACCESS_DENIED",
        message: "Only the competition organiser can reset fixtures"
      });
    }

    // Check if round is locked (picks are closed)
    if (validation.is_round_locked) {
      return res.json({
        return_code: "ROUND_LOCKED",
        message: "Cannot reset fixtures for a locked round"
      });
    }

    // Check if any fixtures have processed results
    if (validation.processed_count > 0) {
      return res.json({
        return_code: "RESULTS_PROCESSED",
        message: "Cannot reset fixtures - some results have already been processed"
      });
    }

    // Check if there are fixtures to reset
    if (validation.fixture_count === 0) {
      return res.json({
        return_code: "NO_FIXTURES_TO_RESET",
        message: "No fixtures found to reset for this round"
      });
    }

    // === GET PICKS TO RESTORE TEAMS ===
    // Before deleting picks, get all team-user combinations to restore to allowed_teams
    // This ensures players get their team choices back since the round is being reset
    const picksToRestoreResult = await query(`
      SELECT DISTINCT
        p.user_id,
        t.id as team_id,
        t.short_name as team_short,
        t.name as team_full_name
      FROM pick p
      INNER JOIN team t ON t.short_name = p.team AND t.is_active = true
      WHERE p.round_id = $1
    `, [round_id]);

    const teamsToRestore = picksToRestoreResult.rows;

    // === ATOMIC TRANSACTION EXECUTION ===
    // Execute all database operations in single transaction to ensure data consistency
    // If any operation fails, all changes are rolled back automatically
    let resetSummary = null;
    await transaction(async (client) => {
      
      // Step 1: Restore teams to allowed_teams for all affected players
      // This must be done BEFORE deleting picks to maintain referential integrity
      let teamsRestoredCount = 0;
      for (const teamRestore of teamsToRestore) {
        const restoreResult = await client.query(`
          INSERT INTO allowed_teams (competition_id, user_id, team_id)
          VALUES ($1, $2, $3)
          ON CONFLICT (competition_id, user_id, team_id) DO NOTHING
          RETURNING id
        `, [validation.competition_id, teamRestore.user_id, teamRestore.team_id]);
        
        // Count successful restorations (where a row was actually inserted)
        if (restoreResult.rows.length > 0) {
          teamsRestoredCount++;
        }
      }

      // Step 2: Delete all picks for this round
      // This removes all player selections, allowing them to pick again
      const deletePicksResult = await client.query(`
        DELETE FROM pick
        WHERE round_id = $1
        RETURNING id
      `, [round_id]);

      // Step 3: Delete all fixtures for this round
      // This clears the fixture list, allowing admin to create new ones
      const deleteFixturesResult = await client.query(`
        DELETE FROM fixture
        WHERE round_id = $1
        RETURNING id
      `, [round_id]);

      // Step 4: Add comprehensive audit log for administrative tracking
      const logDetails = `Admin reset all fixtures for Round ${validation.round_number} - Removed ${deleteFixturesResult.rows.length} fixtures, ${deletePicksResult.rows.length} picks, restored ${teamsRestoredCount} team choices`;
      
      await client.query(`
        INSERT INTO audit_log (competition_id, user_id, action, details)
        VALUES ($1, $2, 'Fixtures Reset', $3)
      `, [validation.competition_id, authenticated_user_id, logDetails]);

      // Prepare reset summary for response
      resetSummary = {
        round_number: validation.round_number,
        fixtures_removed: deleteFixturesResult.rows.length,
        picks_removed: deletePicksResult.rows.length,
        teams_restored: teamsRestoredCount,
        players_affected: validation.affected_players
      };
    });

    // === SUCCESS RESPONSE ===
    // Return comprehensive reset summary for admin visibility
    res.json({
      return_code: "SUCCESS",
      message: "Fixtures reset successfully",
      reset_summary: resetSummary
    });

  } catch (error) {
    // === ERROR HANDLING ===
    // Log detailed error for debugging but return generic message to client for security
    console.error('Reset fixtures error:', {
      error: error.message,
      stack: error.stack?.substring(0, 500), // Truncate stack trace
      round_id: req.body?.round_id,
      user_id: req.user?.id,
      timestamp: new Date().toISOString()
    });
    
    res.json({
      return_code: "SERVER_ERROR",
      message: "Failed to reset fixtures"
    });
  }
});

module.exports = router;
=========== END OF ORIGINAL CODE ===========
*/

// Placeholder export to prevent require() errors
module.exports = { disabled: true, message: 'This route has been disabled - manual fixture management replaced by automated fixture service' };
