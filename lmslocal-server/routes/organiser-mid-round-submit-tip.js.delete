/*
DISABLED: Manual fixture management - now managed via backend fixture service (push-fixtures-to-competitions and push-results-to-competitions APIs)
This entire API has been disabled. To re-enable: uncomment this entire file and restore route registration in server.js

=========== ORIGINAL CODE BELOW (COMMENTED OUT) ===========
/*
=======================================================================================================================================
API Route: organiser-mid-round-submit-tip
=======================================================================================================================================
Method: POST
Purpose: Queue organiser tip emails for competitions where Round 1 has been active for 24+ hours with no results submitted
=======================================================================================================================================
Request Payload:
{}  // No parameters needed - fully automated

Success Response (ALWAYS HTTP 200):
{
  "return_code": "SUCCESS",
  "tips_queued": 3,
  "organisers": [
    {
      "organiser_id": 123,
      "organiser_email": "user@example.com",
      "competition_id": 456,
      "competition_name": "Crown Pub LMS"
    }
  ]
}

Error Response (ALWAYS HTTP 200):
{
  "return_code": "SERVER_ERROR",
  "message": "Failed to queue organiser tips"
}
=======================================================================================================================================
Return Codes:
"SUCCESS"
"SERVER_ERROR"
=======================================================================================================================================
Qualification Criteria:
1. Competition status = 'ACTIVE'
2. Round 1 only
3. 24+ hours since round lock_time
4. No results submitted for any fixture in round
5. Organiser has never received this tip before (any competition)
6. Respects email preferences
=======================================================================================================================================
*/

const express = require('express');
const { query } = require('../database');

const router = express.Router();

const TIP_TYPE = 'update_scores_mid_round';
const EMAIL_TYPE = 'update_scores_mid_round_tip';

const TIP_CONTENT = {
  title: 'You can update scores during the round',
  content: `Did you know? You don't need to wait until all fixtures finish. You can update individual match results as they happen, and players will see their status update in real-time!

This is especially useful for keeping your competition engaging:
• Update results as matches finish throughout the day
• Players get instant feedback on their picks
• Creates more excitement and engagement
• No need to stay up late waiting for all matches to complete

Just head to your Manage Competition page and click "Submit Results" for any finished fixture.`
};

router.post('/', async (req, res) => {
  try {
    // Find all qualifying organisers and competitions
    const qualifyingResult = await query(`
      SELECT DISTINCT
        c.organiser_id,
        c.id as competition_id,
        c.name as competition_name,
        r.id as round_id,
        u.email as organiser_email,
        u.display_name as organiser_name
      FROM competition c
      JOIN round r ON c.id = r.competition_id
      JOIN app_user u ON c.organiser_id = u.id
        AND u.email IS NOT NULL
        AND u.email != ''
        AND u.email NOT LIKE '%@lms-guest.com'
      WHERE UPPER(c.status) = 'ACTIVE'
        AND r.round_number = 1
        AND r.lock_time IS NOT NULL
        AND (NOW() - r.lock_time) > INTERVAL '24 hours'
        AND NOT EXISTS (
          -- No results submitted for any fixture in this round
          SELECT 1 FROM fixture f
          WHERE f.round_id = r.id
          AND f.result IS NOT NULL
        )
        AND NOT EXISTS (
          -- Never sent this tip to this organiser before (any competition)
          SELECT 1 FROM email_queue eq
          WHERE eq.user_id = c.organiser_id
          AND eq.email_type = $1
          AND eq.status IN ('pending', 'sent')
        )
        -- Check email preferences: Global "all emails" is ON
        AND NOT EXISTS (
          SELECT 1 FROM email_preference ep
          WHERE ep.user_id = c.organiser_id
          AND ep.competition_id = 0
          AND ep.email_type = 'all'
          AND ep.enabled = false
        )
        -- Check email preferences: Competition-specific override allows emails
        AND NOT EXISTS (
          SELECT 1 FROM email_preference ep
          WHERE ep.user_id = c.organiser_id
          AND ep.competition_id = c.id
          AND ep.email_type IS NULL
          AND ep.enabled = false
        )
      ORDER BY c.organiser_id
      LIMIT 100
    `, [EMAIL_TYPE]);

    const qualifyingOrganisers = qualifyingResult.rows;

    if (qualifyingOrganisers.length === 0) {
      return res.json({
        return_code: 'SUCCESS',
        tips_queued: 0,
        organisers: []
      });
    }

    // Queue emails for each qualifying organiser
    const queuedOrganisers = [];
    let tipsQueued = 0;

    for (const org of qualifyingOrganisers) {
      try {
        await query(`
          INSERT INTO email_queue (
            user_id,
            competition_id,
            round_id,
            email_type,
            scheduled_send_at,
            template_data,
            status
          ) VALUES ($1, $2, $3, $4, NOW(), $5, 'pending')
        `, [
          org.organiser_id,
          org.competition_id,
          org.round_id,
          EMAIL_TYPE,
          JSON.stringify({
            organiser_email: org.organiser_email,
            organiser_name: org.organiser_name,
            competition_name: org.competition_name,
            competition_id: org.competition_id,
            tip_type: TIP_TYPE,
            tip_title: TIP_CONTENT.title,
            tip_content: TIP_CONTENT.content
          })
        ]);

        tipsQueued++;
        queuedOrganisers.push({
          organiser_id: org.organiser_id,
          organiser_email: org.organiser_email,
          competition_id: org.competition_id,
          competition_name: org.competition_name
        });

      } catch (queueError) {
        console.error(`[organiser-mid-round-submit-tip] Failed to queue for organiser ${org.organiser_id}:`, queueError);
        // Continue with other organisers even if one fails
      }
    }

    return res.json({
      return_code: 'SUCCESS',
      tips_queued: tipsQueued,
      organisers: queuedOrganisers
    });

  } catch (error) {
    console.error('[organiser-mid-round-submit-tip] Error:', error);
    return res.json({
      return_code: 'SERVER_ERROR',
      message: 'Failed to queue organiser tips'
    });
  }
});

module.exports = router;

=========== END OF ORIGINAL CODE ===========
*/

// Placeholder export to prevent require() errors
module.exports = { disabled: true, message: 'This route has been disabled - manual fixture management replaced by automated fixture service' };
